// Code generated by protoc-gen-go-cel-authorize. DO NOT EDIT.
// versions:
//  protoc-gen-go-cel-authorize	{{PluginVersion}}
//  protoc 				        {{ProtocVersion}}
// source: {{.Desc.Path}}

package {{.GoPackageName}}

{{ $f := . }}

var _{{.GoDescriptorIdent.GoName}}_rawAuthorizeOptions = []byte{
    {{ range $value := (protoMarshal .Config) -}}
    {{ printf "0x%02x, " $value}}
    {{- end }}
}

{{ range $s := .Services }}
func New{{.GoName}}AuthzInterceptor(opts ...{{options "RuntimeOptions"}}) ({{authorize "AuthzInterceptor"}}, error) {
    cfg := &{{authorize "AuthorizeOptions"}}{}
    if err := {{proto "Unmarshal"}}(_{{$f.GoDescriptorIdent.GoName}}_rawAuthorizeOptions,cfg); err != nil {
        return nil, err
    }
    lib := {{options "BuildRuntimeLibrary"}}(cfg.Options, opts...)
    m := map[string]{{cel "Program"}}{}
    for k, v := range map[string]struct{
        expr string
        req {{proto "Message"}}
    }{
        {{ range $m := $s.Methods }}
        {{- if $m.MethodRule -}}
            "/{{$s.Desc.FullName}}/{{$m.GoName}}": {expr: `{{$m.MethodRule.Expr}}`, req: &{{QualifiedGoIdent $m.Input.GoIdent.GoImportPath $m.Input.GoIdent.GoName}}{}},
        {{- end}}
        {{end}}
    } {
        if pgr, err := {{authorize "BuildAuthzProgram"}}(v.expr, v.req,  cfg, lib); err != nil {
            return nil, err
        } else {
            m[k] = pgr
        }
    }
    return {{authorize "NewAuthzInterceptor"}}(m), nil
}
{{- end}}